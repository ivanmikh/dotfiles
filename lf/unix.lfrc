# interpreter for shell commands
set shell zsh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# Use the `dim` attribute instead of underline for the cursor in the preview pane
#set cursorpreviewfmt "\033[7;2m"

# Common paths
map gd cd ~/Documents
map gD cd ~/Downloads
map g/ cd /
map gt cd /tmp
map gm cd /mnt

# execute current file (must be executable)
map x $$f
map X !$f

# tmux
map S &tmux neww -c $PWD
cmd vsp &tmux splitw -h -c $PWD
cmd  sp &tmux splitw -v -c $PWD
map <c-n> &tmux splitw -v -c $PWD lf

# Warn about nested instances
&[ "$LF_LEVEL" -eq 1 ] || lf -remote "send $id echoerr \"Warning: You're in a nested lf instance!\""

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

# fzf integration
cmd fzf_cd ${{
    res="$(fzf --reverse --header="Jump to location")"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}

# fzf + ripgrep
cmd fzf_rg ${{
    cmd="rg --column --line-number --no-heading --color=always --smart-case"
    fzf --ansi --disabled --layout=reverse --header="Search in files" --delimiter=: \
        --bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
        --bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
        --bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
        --preview='bat --color=always --highlight-line={2} -- {1}'
}}

# remap search keys
map f
map ff :fzf_cd
map fg :fzf_rg

# trash-cli
cmd trash %trash-put -- $fx
# use '<delete>' key for 'trash'
map <delete> trash
map D trash

# atool
cmd extract ${{
    set -f
    atool -x $fx
}}

# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}
map P :link

# follow symlink
cmd follow-link %{{
    lf -remote "send $id select \"$(readlink -- "$f" | sed 's/\\/\\\\/g;s/"/\\"/g')\""
}}
map gL follow-link

# edit and reload config file
cmd edit-config ${{
    $EDITOR ~/.config/lf/lfrc
    lf -remote "send $id source ~/.config/lf/lfrc"
}}

# select all files or directories
cmd select-type &{{
    set -f
    [ "$#" -eq 0 ] && exit
    files="$(
        find "$PWD" -mindepth 1 -maxdepth 1 -type "$1" $([ "$lf_hidden" = false ] && printf '%s\n' -not -name '.*') -print0 |
        sed -z 's/\\/\\\\/g;s/"/\\"/g;s/\n/\\n/g;s/^/"/;s/$/"/' |
        tr '\0' ' ')"

    lf -remote "send $id :unselect; toggle $files"
}}
cmd select-dirs select-type d
cmd select-files select-type f

# bulk rename with qmv
cmd bulk-rename ${{
    clear
    qmv -d -- $fx
    lf -remote "send $id unselect"
}}

# copy to clipboard
cmd yank-file $printf '%s' "$f" | wl-copy
cmd yank-paths $printf '%s' "$fx" | wl-copy
cmd yank-dirname &printf '%s' "$PWD" | wl-copy
cmd yank-basename &basename -a -- $fx | head -c-1 | wl-copy
cmd yank-basename-without-extension &basename -a -- $fx | sed -E 's/\.[^.]+$//' | head -c-1 | wl-copy

# remap yank
map y
map yy copy
map yp yank-paths
map yd yank-dirname
map yb yank-basename
